# JUC Interview

## ThreadLocal

## sleep() 和 wait() wait(n)  的区别

- sleep 来自 Thread 类，而 wait 来自 Object 类
- sleep 睡眠不释放锁，wait 睡眠释放锁
- sleep 休眠的线程时间到自动恢复，wait 阻塞的线程可以使用 notify 和 notifyAll 唤醒
- 调用 wait 必须在 syncronized 同步代码区中执行且要获得对象锁

## syncronized 锁机制底层原理

`synchronized` 是 Java 中用于实现线程同步的关键字，它保证了多个线程在同一时刻不会同时进入被 `synchronized` 修饰的代码块或方法。`synchronized` 的底层实现涉及到对象头、Monitor 对象、以及相关的指令。

底层实现原理如下：

1. **对象头（Object Header）：**
   - Java 中的每个对象都有一个对象头，用于存储对象的元信息，包括哈希码、锁状态等。
   - 对象头中的 Mark Word 用于存储锁相关的信息，包括偏向锁、轻量级锁、重量级锁等。

2. **Monitor 对象：**
   - Monitor 是一种同步机制，用于控制多个线程对共享资源的访问。每个 Java 对象都与一个 Monitor 相关联。
   - Monitor 包括进入和退出两个部分，分别用于标识线程进入和退出临界区。
   - 每个 Monitor 都有一个计数器，记录被锁定的次数。初始状态下，计数器为 0。

3. **synchronized 进入和退出的底层实现：**
   - **进入 `synchronized` 代码块：**
      - 当线程进入一个被 `synchronized` 修饰的代码块时，它会首先尝试获取对象的锁。
      - 如果对象的锁计数器为 0，表示对象未被锁定，线程将成功获取锁，并将计数器设置为 1。此时，这个线程称为锁的拥有者。
      - 如果对象的锁计数器不为 0，表示对象已经被其他线程锁定，这个线程会进入阻塞状态，直到锁可用。

   - **退出 `synchronized` 代码块：**
      - 当线程退出 `synchronized` 代码块时，它会释放对象的锁，将锁计数器减 1。
      - 如果锁计数器变为 0，表示当前线程已经完全释放了锁，其他等待的线程可以尝试获取锁。

   - **锁的升级：**
      - `synchronized` 关键字的实现还涉及到锁的升级，包括偏向锁、轻量级锁和重量级锁。这些是为了在不同的竞争情况下提供最优的性能。

在 Java 6 之前，主要采用的是重量级锁，即每个对象都有一个关联的监视器（Monitor）实现同步。这种同步机制效率相对较低，因为它涉及到用户态和内核态的切换，会引起较大的性能开销。

Java 6 引入了偏向锁的概念，是一种乐观的锁策略。当一个线程获取锁时，会在对象头的 Mark Word 中存储线程 ID，表示这个对象偏向于这个线程。如果其他线程尝试获取这个锁，会检查偏向锁的线程 ID 是否与自己相同，如果相同，就表示可以获取锁，无需进一步同步操作。如果不相同，则需要进行锁升级。

偏向锁的优势在于，在低竞争环境下，不需要进行额外的同步操作，从而提高了程序的性能。但是在高竞争环境下，偏向锁会逐渐升级为轻量级锁和重量级锁，以确保多个线程之间的公平竞争。

需要注意的是，偏向锁是默认启用的，但在某些情况下可能会被禁用，具体取决于 JVM 的启动参数和运行时的情况。在一些高并发的场景下，偏向锁可能会失效，因为频繁地获取和释放锁会导致偏向锁的撤销。

## 为什么要使用线程池

## volatile 关键字

## volatile 能使得一个非原子操作变成原子操作吗

## 创建线程的方式

- 继承 Thread 类
- 实现 Runnable 接口
- 实现 Callable 接口
- 线程池

## 线程的生命周期

- NEW 新创建的线程，就绪态
- RUNNABLE
- BLOCKED
- WAITING
- TIMED_WAITING
- TERMINATED

## notify() 和 notifyAll() 的区别

## 线程池的创建方式

ThreadPoolExecutor

## 线程池有哪些状态

在Java中，线程池的状态由 `ThreadPoolExecutor` 类的 `runState` 字段表示。`runState` 是一个 `int` 类型的原子变量，代表线程池的状态，它包含了几个可能的状态值，主要有：

1. **RUNNING（运行）：** `RUNNING` 是线程池的正常运行状态。在这个状态下，线程池既可以接受新的任务，也可以处理已经加入的任务。
2. **SHUTDOWN（关闭）：** `SHUTDOWN` 表示线程池不再接受新任务，但会继续处理已经加入队列的任务。
3. **STOP（停止）：** `STOP` 表示线程池不再接受新任务，也不会处理队列中的任务，而且会中断正在执行的任务。
4. **TIDYING（整理）：** `TIDYING` 表示线程池正在停止，同时队列为空。当线程池转换到这个状态时，会执行一些资源释放的工作。
5. **TERMINATED（终止）：** `TERMINATED` 表示线程池已经完全终止。在线程池完全终止后，它将一直保持在这个状态。

## 线程池中 submit() 和 execute() 方法有什么区别

在Java中，`ThreadPoolExecutor` 提供了两种方法来提交任务：`submit()` 和 `execute()`。这两种方法的主要区别在于它们处理任务的返回值和异常的方式。

1. **`submit()` 方法：**
   - 返回一个 `Future` 对象，通过它可以获取任务的执行结果。
   - 可以用 `Future` 的 `get()` 方法来获取任务的执行结果，该方法会阻塞直到任务完成。
   
2. **`execute()` 方法：**
   - 不返回任务的执行结果，方法签名为 `void execute(Runnable command)`。
   - 无法获取任务的执行结果，因为它没有返回 `Future` 对象。
   

## 在 Java 程序中怎么保证多线程的运行安全

- 优先使用不可变类，如 jdk8 中的日期时间类，String 类
- 使用线程安全类，如 juc 下的并发安全类
- syncronized 关键字
- Lock 锁

## synchronized 锁升级的原理是什么

在 Java 中，`synchronized` 关键字用于实现线程的同步，确保在多线程环境中对共享资源的互斥访问。在 Java 6 以后的版本，Java 虚拟机（JVM）对 `synchronized` 关键字的实现进行了优化，引入了锁的升级机制，主要包括偏向锁、轻量级锁和重量级锁。

下面是锁升级的主要原理：

1. **偏向锁（Biased Locking）：**
   - 当一个线程访问同步块并获得锁时，JVM 会在对象头的 Mark Word 中存储线程 ID，表示该对象被当前线程所偏向。
   - 如果在未来的执行中，同一个线程再次尝试获取该锁，无需再进行同步操作，直接获得锁。
   - 这种情况下，锁仍然处于偏向状态。

2. **轻量级锁（Lightweight Locking）：**
   - 当有多个线程竞争同一个锁时，JVM 会将对象的 Mark Word 指向线程的锁记录（Lock Record）的指针。
   - 线程会尝试使用 CAS 操作来将锁记录中的锁标志设置为锁定状态。如果成功，表示线程获得了轻量级锁。
   - 如果失败，说明可能有多个线程争用锁，那么轻量级锁升级为重量级锁。

3. **重量级锁（Heavyweight Locking）：**
   - 当轻量级锁竞争激烈无法获得锁时，会升级为重量级锁。
   - 重量级锁使用操作系统的互斥量来实现，它保证任何时刻只有一个线程能够获得锁。
   - 重量级锁的升级会导致线程阻塞和操作系统切换开销增加。

这种锁的升级机制的设计是为了在不同情况下提供最优的性能。在低竞争情况下，偏向锁和轻量级锁能够减少锁竞争的开销；在高竞争情况下，使用重量级锁可以确保线程公平地获取锁，避免线程饥饿。

## 死锁是什么以及产生死锁的条件

## 怎么防止死锁

- 使用 tryLock 时设置超时时间，超时时可以退出锁的竞争，防止死锁
- 使用已有的并发安全类
- 降低锁的使用粒度，不同临界资源应对应不同的锁

## synchronized 和 volatile 的区别

## 动态代理是什么，有哪些实现方式

JDK 原生动态代理，基于接口；cglib 动态代理，基于继承类。

