# String Constant pool

> Java 中的字符串只能位于内存中的两个区域：字符串常量池和堆。 常量池维护了一个 StringTable，它是一个 hashtable，以字符串 hashcode 作为键，字符串引用作为值；Java 堆中存储的就是普通的字符串对象。

`String`不可变的字符序列，底层维护了一个`final char[] value`数组，这个类提供对字符串的修改方法都是在原字符串的基础上创建新的字符串，而字符串常量池中的字符串引用并未发生变化，因此 String 类是不可变的。

为了弥补 String 不可变的代价，JDK设计了两个可变的字符序列类，即 StringBuilder 和 StringBuffer，这两个类都继承自 AbstractStringBuilder，区别在于 StringBuffer 是线程安全的，而 StringBuilder 则不是，它们底层维护了一个非 final 修饰的 `char[] value`，因此每次对字符串的修改不会创建新的对象，而是在原字符串的基础上拼接新的字符串（数组扩容），如果数组容量不够则会进行扩容拷贝的操作，即底层变化的是数组对象而不是字符串对象。

字符串的不可变是指字符串内容不可变。

空字符串是一个有效的字符串对象，它不等于`null`。

另外 + 运算符是 Java 唯一一个对 String 特殊处理的重载运算符，任何对象与 String 对象相加，都会调用 StringBuilder 的 append 和 Object 的 toString 方法进行拼接，最后调用 StringBuilder 的 toString 方法转为字符串。

一些关于 String 的细节问题。

情形一：

```java
String s="123";
```

虚拟机在处理字面量"123"时，首先在本地栈中创建字符串"123"，随后对其调用本地方法intern()。intern方法检查StringTable中是否存在这个字符串，如果有则返回对其的引用；如果没有，则将该字符串存入常量池中，并将其引用添加至StringTable中。 这里值得注意的是，如果该字符串已经存储于Java堆中，那么intern方法将不会再将其拷贝至常量池中，而是直接将其引用添加至StringTable中。

情形二：

```java
String s=new String("123");
```

"123"按照情形一处理，返回对常量池中字符串常量"123"的引用。随后在Java堆中创建字符串对象，其内容与常量池中的"123"一致。

情形三：

```java
String s1=new String("123");
String s2=s1.intern();
```

第一行按照情形二处理。经过情形二，将产生一个对象和一个常量。而s2将引用常量池中的字面量"123"。为了验证这一说法，进行如下实验：

```java
String s1 = "123";
String s2 = s1.intern();
System.out.println(s1 == s2); // true

String s1 = new String("123");
String s2 = s1.intern();
System.out.println(s1 == s2); // false
```

情形四：

```java
String s=new String("1")+new String("23");

// 上述代码编译器优化为
StringBuilder stringBuilder=new StringBuilder();
stringBuilder.append("1").append("23");
String s=stringBuilder.toString();
```

由于编译器的优化，将字符串拼接转换为StringBuilder操作。最后在Java堆中创建字符串对象。 但是在循环体里面如果使用字符串 String 拼接，编译器无法优化，会先创建 StringBuilder，然后调用 append 方法，接着调用 StringBuilder 的 toString 方法转化为 字符串String对象，重复这样做将创建大量的 String 对象。

常见的转义字符包括：

- `\"` 表示字符`"`
- `\'` 表示字符`'`
- `\\` 表示字符`\`
- `\n` 表示换行符
- `\r` 表示回车符
- `\t` 表示Tab
- `\u####` 表示一个Unicode编码的字符

```java
String s = "abc\"xyz"; // 包含7个字符: a, b, c, ", x, y, z
// 因为\是转义字符，所以，两个\\表示一个\字符
String s = "abc\\xyz"; // 包含7个字符: a, b, c, \, x, y, z
```

**字符串拼接的方法**

- +
- StringBuilder append
- StringBuffer append
- String concat

**其实 switch flow 只支持一种数据类型，那就是整型，其他数据类型都是转换成整型之后再使用 switch 的。**

当代码中出现双引号形式（字面量）创建字符串对象时，JVM 会先对这个字符串进行检查，如果字符串常量池中存在相同内容的字符串对象的引用，则将这个引用返回；否则，创建新的字符串对象，然后将这个引用放入字符串常量池，并返回该引用。

在Java体系中，共有三种常量池。分别是**字符串常量池**、**Class常量池**和**运行时常量池**。

Class常量池可以理解为是Class文件中的资源仓库。 Class文件中除了包含类的版本、字段、方法、接口等描述信息外，还有一项信息就是常量池(constant pool table)，用于存放编译器生成的各种字面量(Literal)和符号引用(Symbolic References)。

由于不同的Class文件中包含的常量的个数是不固定的，所以在Class文件的常量池入口处会设置两个字节的常量池容量计数器，记录了常量池中常量的个数。

常量池计数器是从1开始而不是从0开始的，常量池的个数是10进制的17，这就代表了其中有16个常量，索引值范围为1-16。

常量池中主要存放两大类常量：字面量（literal）和符号引用（symbolic references）。

符号引用是编译原理中的概念，是相对于直接引用来说的。主要包括了以下三类常量： * 类和接口的全限定名 * 字段的名称和描述符 * 方法的名称和描述符。

在《深入理解Java虚拟》中有这样的表述：

Java代码在进行`Javac`编译的时候，并不像C和C++那样有“连接”这一步骤，而是在虚拟机加载Class文件的时候进行动态连接。也就是说，在Class文件中不会保存各个方法、字段的最终内存布局信息，因此这些字段、方法的符号引用不经过运行期转换的话无法得到真正的内存入口地址，也就无法直接被虚拟机使用。当虚拟机运行时，需要从常量池获得对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址之中。

运行时常量池（ Runtime Constant Pool）是每一个类或接口的常量池（ Constant_Pool）的运行时表示形式。

它包括了若干种不同的常量：从编译期可知的数值字面量到必须运行期解析后才能获得的方法或字段引用。运行时常量池扮演了类似传统语言中符号表（ SymbolTable）的角色，不过它存储数据范围比通常意义上的符号表要更为广泛。

每一个运行时常量池都分配在 Java 虚拟机的方法区之中，在类和接口被加载到虚拟机后，对应的运行时常量池就被创建出来。

以上，是Java虚拟机规范中关于运行时常量池的定义。

根据Java虚拟机规范约定：每一个运行时常量池都在Java虚拟机的方法区中分配，在加载类和接口到虚拟机后，就创建对应的运行时常量池。

在不同版本的JDK中，运行时常量池所处的位置也不一样。以HotSpot为例：

在JDK 1.7之前，方法区位于堆内存的永久代中，运行时常量池作为方法区的一部分，也处于永久代中。

因为使用永久代实现方法区可能导致内存泄露问题，所以，从JDK1.7开始，JVM尝试解决这一问题，在1.7中，将原本位于永久代中的运行时常量池移动到堆内存中。（永久代在JDK 1.7并没有完全移除，只是原来方法区中的运行时常量池、类的静态变量等移动到了堆内存中。）

在JDK 1.8中，彻底移除了永久代，方法区通过元空间的方式实现。随之，运行时常量池也在元空间中实现。

运行时常量池中包含了若干种不同的常量：

编译期可知的字面量和符号引用（来自Class常量池） 运行期解析后可获得的常量（如String的intern方法）

所以，运行时常量池中的内容包含：Class常量池中的常量、字符串常量池中的内容

## String intern() 方法

## + 操作符重载

