# Java OOP

## 面向对象的特点

### 封装 Encapsulation

封装的思想是将类向外暴露的信息尽可能的少，即只暴露需要提供给客户端的方法，将这些方法的实现细节使用 private 封装在类的内部，从而保护类的 API 功能正常。另一方面是将对象的状态数据封装在类的内部，只能通过合理正确的 API 进行对象状态的修改。封装体现了 OOP 编程中的高内聚设计思想。

良好的封装也减轻了客户端（API caller）的负担，可以很轻松地发现这个类暴露出的 API。

`private` 访问权限被限定在 `class` 的内部，而且与方法声明顺序*无关*。推荐把`private`方法放到后面，因为`public`方法定义了类对外提供的功能，**阅读代码的时候，应该先关注`public`方法**。

### 继承 Inheritance

继承是为了能用程序体现面向对象世界中的对象关系，即多个对象之间有共同的状态和行为，从而通过继承类达到代码的复用和类继承体系设计的目标，继承也是多态的前提。

继承在 Java 中使用 `extends` 关键字，如果一个类没有继承任何类，那么它隐式地继承 `Object` 类。

Java 只支持单继承，不支持多继承，但是多重继承（层层向上继承）是允许并合理的。

子类继承父类后，可以添加新的字段和方法，以添加独有的状态和行为，也可以重写父类的方法，对于父类中定义的成员，子类除了父类的静态成员以外继承了所有字段和方法，但是对于 `private` 修饰的成员是无法可见的，对于 `static` 修饰的成员是属于类的，子类无法重写。

### 多态 Polymorphism

多态是同一个对象具有多个不同表现形式或形态的能力。多态就是同一个接口（方法），使用不同的实例执行具有不同的结果。多态性分为编译时多态（静态多态）和运行时多态（动态多态）。

**多态的前提**

- 继承或者实现
- 重写方法
- 父类引用指向子类对象或者接口引用指向实现类对象

**多态的好处**

降低了代码的耦合性，引用的对象可以在运行期动态地发生变化。

### 抽象 Abstraction

抽象是 Java 语言独特的特性，在 Java 中，抽象通过抽象类 `abstract class` 和 接口 `interface` 来实现。

抽象类和接口都不能被实例化，抽象类和接口中都可以有抽象方法。

抽象类是用于在类继承体系的设计中，被具体类继承的，表示的是 is-a 的关系；接口中通常定义一组规范，用来表示相关实现都应该遵守且实现的行为，表示的是 has-a 的关系。

抽象类除不能被实例化以外与具体类没有不同，而接口中只能定义 pubic static final 修饰的静态常量和方法，其中在 **Java8 中允许定义静态方法和默认方法**，以弥补接口中不能有方法实现的缺陷而导致的接口维护代价过高。静态方法只能通过接口名调用，默认方法只能通过接口的实现类对象调用。

一个类如果实现一个接口或继承抽象类，那么该类必须实现其中的所有抽象方法，否则它自身也需要被定义为抽象类。当使用 `new` 关键字创建对象时，JVM 会自动调用构造器方法。

**接口与接口之间允许多继承。**

## 构造器

Java 中的构造器（Constructor）用来初始化并创建对象实例，构造器的名称必须与所在类的名称相同，构造器没有返回值，构造器可以重载。如果在定义类时没有编写任意一个构造器时，编译器会自动生成一个无参构造器。

## 类的成员

- 字段
  - 实例字段
  - 静态字段
- 方法
  - 实例方法
  - 静态方法
- 构造器
- 代码块
  - 非静态代码块
  - 静态代码块
- 内部类
  - 成员内部类，编译器自动为该类生成一个指向外部类引用的构造器，即成员内部类中有一个指向外部类对象的引用。
  - 静态成员内部类，只能访问外部类的静态成员。
  - 匿名内部类
  - 局部内部类

## this 和 super

## 抽象类

抽象类可以映射现实世界中的事物，比如动物这样的抽象概念，本身就是不具体的，但是具体的动物如猫、狗、鱼等都具备这一抽象概念的某些行为和状态，因此可以将这类事务描述成 Java 程序中的抽象类，让具体的子类继承它，从而使继承体系的结构设计更加完整。

Java 中的抽象类使用 abstract 关键字修饰，不能被实例化。

抽象类通常可用来实现模板设计模式。

## final

## 权限修饰符

- private
- default
- protected
- public

## 重载和重写

重载发生的范围在一个类中，指有多个相同名称的方法，但是它们的参数类型、参数个数或者参数位置不同，这种情况下，构成了方法的重载，如 System.out.println() 方法；重写发生的范围在两个类之间且必须存在继承的关系，子类重写了父类的方法。

重载的行为是编译期确定的，而重写的行为是运行期确定的。

重写的规则

- 父类 static 或 final 或 private 修饰的方法子类无法重写，另外构造器也无法重写
- 子类重写的方法名称和方法参数列表必须和父类方法一致
- 子类重写的方法的访问修饰符权限不能低于父类方法的权限，如父类是 public，子类不能设置为 protected
- 子类重写的方法返回值必须等于或是父类方法返回值的子类
- 子类方法抛出的异常必须等于或是父类方法抛出异常的子类

重载的规则

- 重载只发生在一个类中
- 重载的方法参数列表必须不相同
- 重载方法的方法返回值和访问修饰符不是重载的标准

`String`类提供了多个重载方法`indexOf()`，可以查找子串：

- `int indexOf(int ch)`：根据字符的Unicode码查找；
- `int indexOf(String str)`：根据字符串查找；
- `int indexOf(int ch, int fromIndex)`：根据字符查找，但指定起始位置；
- `int indexOf(String str, int fromIndex)`根据字符串查找，但指定起始位置。

## 接口

接口是 Java 独特的语法特性，接口定义了一组规范，弥补了 Java 单继承的缺陷。

接口在 Java8 中允许定义静态方法和抽象方法，减少维护接口的代价，否则每次将接口中添加抽象方法，那么实现该接口的类也需要进行改动。

接口使用关键字 interface 定义。

接口之间允许多重继承。

接口不能被实例化，类实现了接口则需要实现接口中的全部抽象方法，否则必须被定义为抽象类。

接口中只允许定义 public static final 修饰的静态常量。

接口中的默认方法修饰符都是 public abstract 修饰的抽象方法。

### 标记接口

Java 自定义了一些标记接口用于在运行时检查，如 Serializable 序列化接口、RandomAccess 接口、Cloneable 可复制接口。这些接口中都没有任何的字段和方法，只是用来标记一个类是否具备该接口所描述的功能设计。如果一个类没有实现 Serializable 接口，那么对象在序列化或反序列化的时候就会抛出序列化异常，类似地如果类没有实现 Cloneable 接口，而对象调用了 clone() 方法，那么这种行为在运行期也会被检查出来，虚拟机会抛出 CloneNotSupportedException 异常。

## 内部类

Java 支持四种内部类

- 成员内部类
- 静态成员内部类
- 局部内部类
- 匿名内部类

**其中静态成员内部类和匿名内部类的使用最为广泛。**

### 成员内部类

定义在类的成为位置，可以访问外部类的所有成员，包括私有成员，当成员名称冲突时（内部类定义了和外部类同名的成员）可以使用 外部类.this.成员名 访问外部类的成员，这是因为作用域优先级的原因。

Inner Class除了有一个`this`指向它自己，还隐含地持有一个Outer Class实例，可以用`Outer.this`访问这个实例。所以，实例化一个Inner Class不能脱离Outer实例。

观察Java编译器编译后的`.class`文件可以发现，`Outer`类被编译为`Outer.class`，而`Inner`类被编译为`Outer$Inner.class`。

### 静态成员内部类

静态成员内部类区别与成员内部类的主要一点就是它使用 static 关键字修饰，该类只能访问外部类的静态成员。

### 局部内部类

局部内部类定义在类的方法中，作用相当于一个局部变量。

### 匿名内部类

匿名内部类通常是实现一个接口或继承一个父类的类，并且通过实例化该匿名内部类作为方法的参数传递，结合 Lambda 表达式。

Java编译器编译后的`.class`文件可以发现，`Outer`类被编译为`Outer.class`，而匿名类被编译为`Outer$1.class`。如果有多个匿名类，Java编译器会将每个匿名类依次命名为`Outer$1`、`Outer$2`、`Outer$3`……